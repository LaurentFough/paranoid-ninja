#!/bin/sh

title() {
  if ! $QUIET ; then
    printf "${cyan}%s${red}%s${cyan}%s${endc}\n" "---" " $1 " "---"
  fi
}

log() { 
  if ! $QUIET ; then
    printf "${green}%s${white}%s${endc}\n" "[+]" " $1"
  fi 
}

die() {
  printf "${red}%s${white}%s${endc}\n" \
    "[-]" " $1"
  exit 1
}

checkRoot() {
  if [[ "$(id -u)" -ne 0 ]] ; then
    die "Please run this program as a root"
  fi
}

#######################################################
# Command option

loadEnv() {
  local env dir=$(pwd)
  if [ -f /etc/conf.d/paranoid-ninja ] ; then
    source /etc/conf.d/paranoid-ninja
  elif [ -f $dir/src/env ] ; then
    source $dir/src/env
  else 
    die "file env no found env=$dir/src/env"
  fi
}

checkConfigFile() {
  local relativ full
  relativ="$DIR/$1"
  full="${1-:/etc/paranoid/paranoid.conf}"
  if [ -f "$relativ" ] ; then
    source "$relativ"
  elif [ -f "$full" ] ; then
    source "$full"
  else
    die "No config file found"
  fi
}

checkBins() {
  for i in $@ ; do
    if ! which $i > /dev/null 2>&1 ; then
      die "$i no found"
    fi
  done
}

#######################################################
# Backup

backupFiles() {
  local b backup_list
  backup_list="$1"
  if [ $BACKUP_DIR ] ; then
    [[ ! -d $BACKUP_DIR ]] && mkdir -p $BACKUP_DIR
    # $f can be a directory or a file
    for b in $backup_list ; do
      if [[ -f "$BACKUP_DIR/${b##*/}" ]] ; then
        echo -n
      elif [[ -d "$BACKUP_DIR/${b##*/}" ]] ; then
        echo -n
      else
        echo "[*] backup $b to $BACKUP_DIR ..."
        cp -a "$b" "$BACKUP_DIR/"
      fi
    done
  else
    echo "[*] backup_dir is unset from config file, skip"
  fi
}

cpy() {
  local src dest
  src="$1"
  dest="$2"
  if [[ -f $src ]] || [[ -d $src ]] ; then
    echo "[+] cp -a $src $dest"
    cp -a $src $dest
  fi
}

restoreFiles() {
  local dir f
  dir=$BACKUP_DIR
  [[ -z $dir ]] && die "$dir no found"
  cpy $dir/hostname /etc/default/hostname
  cpy $dir/hosts /etc/hosts
  cpy $dir/resolv.conf /etc/resolv.conf
  cpy $dir/sysctl.conf /etc/sysctl.conf
  cpy $dir/torrc /etc/tor/torrc
  cpy $dir/.ssh $ssh_dir
  for f in $other_host_files ; do
    cpy $dir/${f##*/} $f
  done
}

#######################################################
# Firewall

nftReload() {
  local files f
  files="/var/lib/nftables/rules-save /etc/nftables.conf"
  for f in $files ; do
    if [ -f $f ] ; then
      $NFT flush ruleset
      $NFT -f $f
    fi
  done
}

iptReload() {
  local files f
  files="/var/lib/iptables/rules-save /etc/iptables/iptables.rules"
  for f in $files ; do
    if [ -f $f ] ; then
      $IPT_RES $f
    fi
  done
}

searchTorUid() {
  local tor_uid
  if tor_uid=$(id -u debian-tor 2>&1 | grep "^[0-9]") ||
    tor_uid=$(id -u tor 2>&1 | grep "^[0-9]") ; then
      echo $tor_uid
  else
    die "$0: tor_uid no found"
  fi
}

clearIptables() {
  local ipt=$(which iptables)
  $ipt -F
  $ipt -F -t nat
  $ipt -X
  $ipt -P INPUT DROP
  $ipt -P OUTPUT DROP
  $ipt -P FORWARD DROP
}

#######################################################
# Hostname

# Write the new hostname in file from $other_host_files
otherHostFiles() {
  local f rule
  rule="$1"
  if [ $other_host_files ] ; then
    for f in $other_host_files ; do
      [[ -f $f ]] &&
        sed -i "$rule" $f
    done
  fi
}

# forXorg, avoid error like display no found
# http://ubuntuhandbook.org/index.php/2016/06/change-hostname-ubuntu-16-04-without-restart/
addXauth() {
  local user
  user=$(echo ${xauthority_file%/*} | sed s:/home/::g)
  $XAUTH_COM add "$1" $2 $3 &&
  $XAUTH_COM remove "$4" &&
  chown $user:$user $xauthority_file || die "xauth - fail to change $xauthority_file"
  unset XAUTH_COM
}

checkXauth() {
  local dpy new_dpy proto hexkey new_host ifarg
  ifarg="${1:-unix}"
  new_host=$(cat /etc/hostname | head -n 1)
  dpy=$($XAUTH_COM list | grep $ifarg | awk '{print $1}')
  proto=$($XAUTH_COM list | grep $ifarg | awk '{print $2}')
  hexkey=$($XAUTH_COM list | grep $ifarg | awk '{print $3}')
  if [[ -z $dpy ]] || [[ -z $proto ]] || [[ -z $hexkey ]] ; then
    die "xauth - unable to find information on $xauthority_file with $ifarg"
  fi
  new_dpy="$(echo $dpy | sed s:${dpy%/*}:$new_host:g)"
  addXauth "$new_dpy" "$proto" "$hexkey" "$dpy"
}

forXauth() {
  local if_one old_host XAUTH_COM="$XAUTH -f $xauthority_file"
  export XAUTH_COM
  [[ -z $XAUTH ]] && die "xauth - xauth is no found ..."
  if [[ $xauthority_file ]] && [[ -f $xauthority_file ]] ; then
    if_one=$($XAUTH_COM list | wc -l)
    old_host="$1"
    if [[ $if_one == 1 ]] ; then
      echo "[+] xauth - changing the single entry..."
      checkXauth
    elif [[ $old_host ]] ; then
      echo "[+] xauth - there is more than one entry, check with $old_host"
      checkXauth "$old_host"
    else
      die "xauth - unable to change the hostname $old_host"
    fi
  else
    echo "[*] xauth - file $xauthority_file no found, skip..."
  fi
}

# exec if ssh_dir is set from conf file.
updSshKey() {
  local old new user file if_user_host
  user="$1"
  file="$2"
  old=$(grep $user $file | awk '{print $3}')
  new=$(cat /etc/hostname | head -n 1)
  if if_user_host=$(grep $user $file) ; then
    echo "[+] ssh - changed $user@$new at $file..."
    sed -i "s:$old:$user@$new:g" $file
  else
    echo "[+] ssh - changed $new at $file..."
    sed -i "s:$3:$new:g" $file
  fi
}

forSsh() {
  local user file pub_key if_pub_key f
  user=$(echo ${ssh_dir%/*} | sed s:/home/::g)
  file="$(find $ssh_dir -type f | xargs grep $user | awk '{print $1}')"
  pub_key="$(grep $user $ssh_dir/authorized_keys | awk '{print $2}')"
  for f in $file ; do
    updSshKey $user ${f%%:*}
  done
  if [[ $pub_key ]] && if_pub_key=$(grep ${pub_key:0:20} $ssh_dir/known_hosts | awk '{print $1}' | head -n 1) ; then
    echo "[*] ssh - found a old hostname in $ssh_dir/known_hosts"
    updSshKey $user $ssh_dir/known_hosts $if_pub_key
  fi
}

# Write new value of hostname in multiple files
writeHost() {
  local new old file files rule xorg
  # check if Xorg running
  xorg="$(pgrep -x Xorg)"
  # /etc/hostname
  new="$1"
  old="$(cat /etc/hostname | head -n 1)"
  files="/etc/hostname /etc/hosts"
  rule="s:$old:$new:g"
  for file in $files ; do
    sed -i "$rule" $file || die "sed 1"
  done
  forSsh
  [[ ! -z $xorg ]] && forXauth "$old"
  otherHostFiles "$rule"
  $HOSTNAME $new
}

#######################################################
# Check network

checkIp() {
  local ext_ip
  printf "%s %s\\n" \
    "==>" "Checking your public IP, please wait..."
  if ext_ip="$(curl -s -m 10 https://ipinfo.io)" ; then
    printf "%s\\n" "$ext_ip" | tr -d '"{}' | sed 's/ //g'
  elif ext_ip="$(curl -s -m 10 https://ip-api.com)" ; then
    printf "%s\\n" "$ext_ip" | tr -d '"{}' | sed 's/ //g'
  else
    printf "%s\\n" "[ failed ] curl: HTTP request error"
    exit 1
  fi
}

testTor() {
  local url
  url="https://check.torproject.org/"
  curl -s -m 10 -L "$url" | cat | tac | grep -q 'Congratulations'
  if [ $? -eq 0 ] ; then
    echo "[+] Tor is working properly"
    checkIp
  else
    echo "[-] Unfortunately, Tor is no working"
  fi
  exit 0
}

isValidAddress() {
  if ipcalc $1 | grep -i invalid ; then
    die "target $1 is not a valid address"
  else
    return 0
  fi
}

ctrl_net_device() {
  if ! ip a | awk '{print $2}' | grep -qi $net_device:$ ; then
    die "net_device $net_device no found"
  fi
}

killDhcp() {
  if old=$(pgrep -x dhcpcd) ; then
    pkill dhcpcd > /dev/null
    log "Kill a PID $old dhcpcd"
  fi
  old=
}

#######################################################
# MAC functions

ctrl_static_mac() {
  if [ $static_mac == 'random' ] ; then
    :
  elif echo $static_mac | grep -q "[0-9]*:[0-9]*:[0-9]*:[0-9]*:[0-9]*:[0-9]*" ; then
    :
  else
    die "Value of static_mac $static_mac is incorrect"
  fi
}

#######################################################
# Other Daemon

launchService() {
  local if_here
  echo "check service $1"
  if if_here=$(pgrep -x $1) ; then
    echo "[+] Restarting $1 ..."
    $SYSTEMCTL restart $1 &
    sleep 3
  fi
}

#  launchService ${sshuttle_service_name%.*}
restartDaemons() {
  #local daemon daemons="tor docker sshuttle"
  local daemon daemons="tor docker"
  for daemon in $daemons ; do
    launchService $daemon
  done
}
